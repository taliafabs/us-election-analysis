---
title: "Forecasting the 2024 U.S. Presidential Election"
subtitle: "President Joe Biden Projected to win the Popular Vote Based on MRP Analysis"
author: 
  - Talia Fabregas
thanks: "Code and data are available at: https://github.com/taliafabs/us-election-analysis.git"
date: today
date-format: long
abstract: "First sentence. Second sentence. Third sentence. Fourth sentence."
format: pdf
number-sections: true
bibliography: references.bib
---

```{r}
#| include: false
#| warning: false
#| message: false
#| eval: true

library(tidyverse)
library(janitor)
library(rstanarm)
library(readr)
library(ggplot2)
library(knitr)
library(arrow)
library(kableExtra)
library(modelsummary)
library(MASS)
library(broom.mixed)
library(gutenbergr)
library(haven)
library(labelled)
library(tidybayes)
library(tidyverse)

## load data
# change file path to the location of cleaned survey and poststrat data on local computer
setwd("/Users/talia/us-election-analysis")
survey_analysis_data <- arrow::read_parquet("data/analysis_data/survey_analysis_data.parquet")

survey_analysis_subset <- arrow::read_parquet("/Users/talia/us-election-analysis/data/analysis_data/survey_analysis_subset.parquet")

poststrat_analysis_data <- arrow::read_parquet("data/analysis_data/poststrat_analysis_data.parquet")
```


# Introduction

Every four years, American adults head to the polls to elect their president. The 2024 United States presidential election will take place on Tuesday November 5, 2024. Amidst unprecedented levels of political polarization and distrust in democratic institutions, America will see a rematch of the 2020 election. President Joe Biden will seek a second term and former president Donald Trump will try to become the second president to serve two non-consecutive terms. 

The survey data set that I used was provided by the 2022 Cooperative Election Study (CES) and downloaded from Harvard Dataverse. The CES is a nationally representative survey of 60,000 American adults, conducted before and after U.S. presidential and midterm elections [@survey]. It aims to study the voting behavior of American adults and how it is influenced by geographic and demographic factors [@survey]. I selected a subset of the final release of the 2022 CES Common Content Dataset to use as my survey data. The post-stratification data that I used was downloaded from the Integrated Public Use Microdata Series (IPUMS) USA online database. IPUMS provides survey and census data, dating back to 1850, with the help of 105 statistical organizations [@citeIPUMS]. I selected a subset of the 2022 American Communities Survey (ACS). I use multi-level regression with post-stratification (MRP) to use as my post-stratification data. I performed MRP analysis to forecast the 2024 U.S. presidential election. This involves using a smaller survey dataset (~10,000 respondents) to fit a model to predict vote preference based on geographic and demographic characteristics and then applying it to a larger post-stratification dataset (~500,000 respondents). The model will learn how to classify respondents as Trump or Biden voters using the survey dataset. It will then use what it has learned to classify ACS respondents as Trump or Biden voters when applied to the post-stratification dataset. I will use these results to predict the popular vote and electoral college results of the 2024 U.S. presidential election.


I used R programming language [@citeR] and the `tidyverse` [@citetidyverse], `janitor` [@citejanitor], `ggplot` [@citeggplot2], `knitr` [@citeknitr], `readr` [@citereadr], `arrow` [@citearrow], and `rstanarm` [@citerstanarm] packages to clean my survey and post-stratification datasets, create my data visualizations, fit my logistic regression model, and apply my logistic regression model.

# Data {#sec-data}

## Survey Data {#sec-survey}
```{r}
#| echo: false
#| warning: false
#| message: false
#| eval: true
#| label: fig-subsetrace
#| fig-cap: Preferred presidential candidates of survey subset respondents, by gender and race

survey_analysis_subset$vote24 <- ifelse(survey_analysis_subset[,1] == 1, "Joe Biden", "Donald Trump")

survey_analysis_subset |>
  ggplot(aes(x = race, fill = vote24)) +
  stat_count(position = "dodge") +
  facet_wrap(facets = vars(sex)) +
  theme_minimal() +
  labs(
    x = "Race",
    y = "Number of respondents",
    fill = "Preferred Presidential Candidate"
  ) +
  coord_flip() +
  scale_fill_brewer(palette = "Set1") +
  theme(legend.position = "bottom")
# code for this graph was obtained from telling stories with data chapter 13
```

```{r}
#| echo: false
#| warning: false
#| message: false
#| eval: true
#| label: fig-subseteduc
#| fig-cap: Preferred presidential candidates of survey subset respondents, by highest level of education

survey_analysis_subset |>
  ggplot(aes(x = educ, fill = vote24)) +
  stat_count(position = "dodge") +
  facet_wrap(facets = vars(sex)) +
  theme_minimal() +
  labs(
    x = "Highest Level of Education",
    y = "Number of respondents",
    fill = "Preferred Presidential Candidate"
  ) +
  coord_flip() +
  scale_fill_brewer(palette = "Set1") +
  theme(legend.position = "bottom")
# code for this graph was obtained from telling stories with data chapter 13
```

```{r}
#| echo: false
#| warning: false
#| message: false
#| eval: true
#| label: fig-subset-urban_rural
#| fig-cap: Preferred presidential candidate of subset respondents living in urban vs rural areas

survey_analysis_subset |>
  ggplot(aes(x = urban, fill = vote24)) +
  stat_count(position = "dodge") +
  facet_wrap(facets = vars(sex)) +
  theme_minimal() +
  labs(
    y = "Number of respondents",
    fill = "Preferred Presidential Candidate"
  ) +
  scale_fill_brewer(palette = "Set1") +
  theme(legend.position = "bottom")

# code for this graph is from telling stories with data chapter 13
```
```{r}
#| echo: false
#| warning: false
#| message: false
#| eval: true
#| label: fig-subset-state2020_subset
#| fig-cap: Preferred presidential candidate of subset respondents in states won by Trump vs Biden in 2020
#| 
survey_analysis_subset$StateWinner2020 <- ifelse(survey_analysis_subset[,3] == 1, "Blue States", "Red States")
survey_analysis_subset |>
  ggplot(aes(x = StateWinner2020, fill = vote24)) +
    facet_wrap(facets = vars(sex)) +
  stat_count(position = "dodge") +
  theme_minimal() +
  labs(
    y = "Number of respondents",
    fill = "State winner in 2020"
  ) +
  scale_fill_brewer(palette = "Set1") +
  theme(legend.position = "bottom")
```

```{r}
#| echo: false
#| warning: false
#| eval: true
#| message: false
#| label: fig-electoral-map-survey-subset
#| fig-cap: Electoral college map based on the subsetted survey data

library(ggplot2)
library(statebins)

# this code comes from matthewwankiewicz 
# US_election_forecast/paper/forecasting_us_election.rmd
# also cited in text

survey_analysis_subset <- na.omit(survey_analysis_subset)
survey_electoral_map <- survey_analysis_subset %>%
  group_by(state) %>%
  summarise(prop = mean(vote_biden))

survey_electoral_map %>%
  mutate(statename = str_to_title(state)) %>%
  ggplot(aes(fill = prop, state = statename)) +
  geom_statebins() +
  scale_fill_gradient2(low = "#d12531", high = "#244999",
                       mid = "white", midpoint = 0.5) +
  theme_classic() +
  theme(axis.line = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank()) +
  labs(fill = "Proportion Voting \nfor Biden")
```

@fig-electoral-map-survey illustrates the proportion of subsetted survey respondents in each state who plan to support President Biden in the 2024 election. My subsetted survey dataset appears to show stronger support for President Joe Biden than the genral U.S. electorate both overall and at the state level. As shown in @sec-survey-details, this is not unique to the subsetted data; the complete 2022 CES Common Content Dataset shows strong support for President Biden and the Democratic Party based on 2016 vote choice (`presvote16post`), 2020 vote choice (`presvote20post`), and party identification (`pid3`). However, as seen in subset-state2020_subset, respondents who live in states won by Biden in 2020 (blue states) were more likely to support him over Trump in 2024 than those who live in states won by former president Trump in 2020 (red states). To account for this difference, and the fact that the survey dataset I used has strong support for President Biden, I created the `biden_won` variable, which is equal to 1 if a state was carried by President Biden in 2020 and 0 if it was carried by former President Trump in 2020. The data cleaning steps that I used to create the `biden_won` variable are outlined in @sec-data-cleaning-details.

```{r}
#| echo: false
#| warning: false
#| message: false
#| label: tbl-subset_results
#| tbl-cap: Popular vote and electoral college based on subset survey data


electoral_college <- read_csv("/Users/talia/us-election-analysis/data/analysis_data/electoral_college_votes.csv", show_col_types = FALSE)
# downloaded and cleaned it
electoral_college$state <- tolower(electoral_college$state)

electoral_college$electoral_votes <- as.numeric(electoral_college$electoral_votes)

prop_biden_states <- survey_analysis_subset %>%
  group_by(state) %>%
  summarise(prop = mean(vote_biden))

prop_biden_states$state <- tolower(prop_biden_states$state)

merged_subset_ec <- merge(electoral_college, prop_biden_states, by="state")

biden_states <- merged_subset_ec |>
  filter(prop > 0.5)

trump_states <- merged_subset_ec |>
  filter(prop <= 0.5)

biden_ec_survey <- sum(biden_states$electoral_votes)
trump_ec_survey <- sum(trump_states$electoral_votes)

num_respondents <- nrow(survey_analysis_subset)
num_biden <- sum(survey_analysis_subset$vote_biden)
num_trump <- num_respondents - num_biden

percent_biden = round((num_biden / num_respondents)*100, 2)
percent_trump = round((num_trump / num_respondents)*100,2)

biden_survey <- tibble(
  "Survey Estimate:" = c("Num Votes", "% Votes", "Electoral College"),
  "Biden" = c(num_biden,
              percent_biden,
              biden_ec_survey
              ),
  "Trump" = c(num_trump,
              percent_trump,
              trump_ec_survey)
)

# Set row names
rownames(biden_survey) <- NULL

# Render the table using kable
kable(biden_survey, align = "c") %>%
  kable_styling(bootstrap_options = "striped", full_width = F)
```


## Poststratification Data {#sec-poststrat}

```{r}
#| echo: false
#| warning: false
#| message: false
#| eval: true
#| label: fig-demographics1
#| fig-cap: Survey vs post-stratification voter demographics

# steps here were obtained from matthewwankiewicz US_election_forecast github repo

gender <- survey_analysis_data %>% 
  group_by(sex) %>% 
  summarise(n = n()) %>% 
  mutate(pct = n/sum(n), type = "survey",
         group = "gender") %>% 
  rename(level = sex)

races <- survey_analysis_data %>% 
  group_by(race) %>% 
  summarise(n = n()) %>% 
  mutate(pct = n/sum(n), type = "survey",
         group = "races") %>% 
  rename(level = race)

education <- survey_analysis_data %>% 
  group_by(educ) %>% 
  summarise(n = n()) %>% 
  mutate(pct = n/sum(n), type = "survey",
         group = "education") %>% 
  drop_na(educ) %>% 
  rename(level = educ)

age <- survey_analysis_data %>% 
  group_by(age_bracket) %>% 
  summarise(n = n()) %>% 
  mutate(pct = n/sum(n), type = "survey",
         group = "age") %>% 
  rename(level = age_bracket)

hispanic <- survey_analysis_data %>%
  group_by(hispanic) %>%
  summarise(n = n()) %>%
  mutate(pct = n/sum(n), type = "survey",
         group = "hispanic") %>%
   rename(level = hispanic)

gender_poststrat <- poststrat_analysis_data %>% 
  group_by(sex) %>% 
  summarise(n = n()) %>% 
  mutate(pct = n/sum(n), type = "post-stratification",
         group = "gender") %>% 
  rename(level = sex)

races_poststrat <- poststrat_analysis_data %>% 
  group_by(race) %>% 
  summarise(n = n()) %>% 
  mutate(pct = n/sum(n), type = "post-stratification",
         group = "races") %>% 
  rename(level = race)

education_poststrat <- poststrat_analysis_data %>% 
  group_by(educ) %>% 
  summarise(n = n()) %>% 
  mutate(pct = n/sum(n), type = "post-stratification",
         group = "education") %>% 
  drop_na(educ) %>% 
  rename(level = educ)

age_poststrat <- poststrat_analysis_data %>% 
  group_by(age_bracket) %>% 
  summarise(n = n()) %>% 
  mutate(pct = n/sum(n), type = "post-stratification",
         group = "age") %>% 
  rename(level = age_bracket)

state_poststrat <- poststrat_analysis_data %>% 
  group_by(state) %>% 
  summarise(n = n()) %>% 
  mutate(pct = n/sum(n), type = "post-stratification",
         group = "state") %>% 
   rename(level = state)

hispanic_poststrat <- poststrat_analysis_data %>%
  group_by(hispanic) %>%
  summarise(n = n()) %>%
  mutate(pct = n/sum(n), type = "post-stratification",
         group = "hispanic") %>%
rename(level = hispanic)

## combine the demographic variables into a single data set

demographic_variables <- rbind(gender, gender_poststrat, 
                               age, age_poststrat, 
                               education, education_poststrat)

demographic_variables |> ggplot(aes(as.factor(level), pct, group=as.factor(type), linetype = as.factor(type))) +
  geom_line() + facet_grid(~group, scales = "free") +
  theme(axis.text.x = element_text(angle=70, size = 6, hjust = 1), legend.position = "bottom") +
  labs(x = "Category", y = "Proportion", linetype = "data set") +
  scale_y_continuous(labels = scales::percent) +
  geom_hline(yintercept = 0.5, alpha = 0.35) 
```

```{r}
#| echo: false
#| warning: false
#| message: false
#| eval: true
#| label: fig-datasetraces
#| fig-cap: Survey vs post-stratification voter race demographics
race_variables <- rbind(races, races_poststrat,
                        hispanic, hispanic_poststrat)

race_variables |> ggplot(aes(as.factor(level), pct, group=as.factor(type), linetype = as.factor(type))) +
  geom_line() + facet_grid(~group, scales = "free") +
  theme(axis.text.x = element_text(angle=70, size = 6, hjust = 1), legend.position = "bottom") +
  labs(x = "Category", y = "Proportion", linetype = "data set") +
  scale_y_continuous(labels = scales::percent) +
  geom_hline(yintercept = 0.5, alpha = 0.35) 
```

```{r}
#| echo: false
#| warning: false
#| message: false
#| eval: true
#| label: fig-stateprops
#| fig-cap: Survey and Post-Stratification Data Proportion of Voters by State

# steps obtained from matthewwankiewicz github repo US_election_forecast

survey_analysis_data$state <- tolower(survey_analysis_data$state)
state <- survey_analysis_data %>%
  group_by(state) %>%
  summarise(n = n()) %>%
  mutate(pct = n/sum(n), type = "survey",
         group = "state") %>%
   rename(level = state)

state_poststrat <- poststrat_analysis_data %>%
  group_by(state) %>%
  summarise(n = n()) %>%
  mutate(pct = n/sum(n), type = "post-stratification",
         group = "state") %>%
   rename(level = state)

voters_by_state <- rbind(state, state_poststrat)

voters_by_state |> ggplot(aes(as.factor(level), pct, group=as.factor(type), linetype = as.factor(type))) +
  geom_line() + facet_grid(~group, scales = "free") +
  theme(axis.text.x = element_text(angle=70, size = 6, hjust = 1)) +
  labs(x = "State", y = "% of Voters", linetype = "Data Set")+
  scale_y_continuous(labels = scales::percent)
```


# Model
I performed multi-level regression with post-stratification (MRP) to predict support for president Joe Biden and former president Donald Trump in the 2024 U.S. presidential election. To perform MRP analysis, I fit the model on the survey data and applied it to the post-stratification data. Fitting the logistic regression model on the survey data teaches it to classify each respondent as a Biden or Trump voter based on the state that they live in, whether Biden or Trump won that state in 2020, their sex, age bracket, race, highest level of education, and whether they live in an urban area. I then apply the model to my post-stratification dataset [@citeIPUMS] to forecast the popular vote and electoral college results for the 2024 U.S. presidential election. When applied to my post-stratification dataset, the logistic regression model uses the same variables (state, whether Biden or Trump won that state in 2020, sex, age bracket, race, highest level of education, and urban) and what it learned from being fit on the survey dataset to classify each census respondent as a Biden or Trump voter. 

## Model set-up {#sec-model1}
I built my Bayesian Logistic Regression model in R [@citeR] using the `stan_glm` function and the default priors of the `rstanarm` package [@rstanarm]. My model is as follows:

\begin{align*} 
vote\_biden_i|\pi_i &\sim \mbox{Bern}(\pi_i) \\
\small
\mbox{logit}(\pi_i) &= \beta_0 + \beta_1 \text{state}_i + \beta_2  \text{biden\_won}_i + \beta_3 \text{sex}_i +\beta_4 \text{age\_bracket}_i \\
&+ \beta_5 \text{race}_i + \beta_6 \text{hispanic}_i + \beta_7 \text{educ}_i + \beta_8 \text{urban}_i \\
\beta_0 &\sim \mbox{Normal}(0, 2.5) \\
\beta_1 &\sim \mbox{Normal}(0, 2.5) \\
\beta_2 &\sim \mbox{Normal}(0, 2.5) \\
\beta_3 &\sim \mbox{Normal}(0, 2.5) \\
\beta_4 &\sim \mbox{Normal}(0, 2.5) \\
\beta_5 &\sim \mbox{Normal}(0, 2.5) \\
\beta_6 &\sim \mbox{Normal}(0, 2.5) \\
\beta_7 &\sim \mbox{Normal}(0, 2.5) \\
\beta_8 &\sim \mbox{Normal}(0, 2.5) \\
\end{align*}

where the binary indicator variable vote\_biden_{i} is equal to 1 if the respondent's preferred 2024 presidential candidate is President Joe Biden (D) , or 0 if their preferred candidate is former President Donald Trump (R). My model uses logistic regression, it is not without tradeoffs. Firstly, logistic regression can only be used to predict a binary outcome variable. As far as my model is concerned, the only two vote choices for U.S. adults in the upcoming presidential election are Joe Biden and Donald Trump. The possibilities of voting third-party or not voting at all are not considered. I discuss the tradeoffs, benefits, weaknesses, and limitations associated with the use of a logistic regression model to forecast the U.S. election in more depth in @sec-lr.


### Model justification

```{r}
#| echo: false
#| eval: true
#| warning: false
#| message: false

# use this model to predict the following:
# overall support for biden
# support by state for biden
# electoral college map

# load the model with readRDS
us_election_model <-
  readRDS(file = here::here("models/us_election_model.rds"))
```


# Results {#sec-results}

## Popular Vote Prediction
I got my popular vote prediction by applying the model outlined in @sec-model1 to my post-stratification data set to predict the 2024 preferred presidential candidate of each ACS 2022 respondent [@citeIPUMS].
@tbl-poststrat_results1
```{r}
#| echo: false
#| warning: false
#| message: false
#| eval: true
#| include: true
#| label: tbl-poststrat_results1
#| tbl-cap: "2024 U.S. election popular vote estimates based on post-stratification analysis"

props <- poststrat_analysis_data %>%
  group_by(state, biden_won, race, hispanic, age_bracket, sex, educ, urban) %>%
  summarise(n = n()) %>%
  ungroup() %>%
  group_by(state) %>%
  mutate(prop = n / sum(n))

num_per_state <- poststrat_analysis_data %>%
  group_by(state) %>%
  summarise(total_respondents = n())

biden_support_by_state <- us_election_model %>%
  add_epred_draws(newdata = props) %>%
  rename(support_biden_predict = .epred) %>%
  mutate(support_biden_predict_prop = support_biden_predict * prop) %>%
  group_by(state, .draw) %>%
  summarise(support_biden_predict = sum(support_biden_predict_prop)) %>%
  group_by(state) %>%
  summarise(
    mean = mean(support_biden_predict),
    lower = quantile(support_biden_predict, 0.025),
    upper = quantile(support_biden_predict, 0.975)
  )


merged_states <- merge(num_per_state, biden_support_by_state, by="state")

merged_states$mean_weighted_sum <- merged_states$total_respondents * merged_states$mean
merged_states$lower_weighted_sum <- merged_states$total_respondents * merged_states$lower
merged_states$upper_weighted_sum <- merged_states$total_respondents * merged_states$upper

biden_mean <- sum(merged_states$mean_weighted_sum) / sum(merged_states$total_respondents)
biden_lower <- sum(merged_states$lower_weighted_sum) / sum(merged_states$total_respondents)
biden_upper <- sum(merged_states$upper_weighted_sum) / sum(merged_states$total_respondents)

biden_popvote <- tibble(
  "Estimate:" = c("Lower Estimate", "Mean Estimate", "Upper Estimate"),
  "Biden %" = c(round(biden_lower * 100, 2),
                round(biden_mean * 100, 2),
                round(biden_upper * 100, 2)),
  "Trump %" = c(round((1 - biden_lower) * 100, 2),
                round((1 - biden_mean) * 100, 2),
                round((1 - biden_upper) * 100, 2))
)

# 
# Set row names
rownames(biden_popvote) <- NULL

# popular vote table
kable(biden_popvote, align = "c") %>%
  # kable_styling(bootstrap_options = "striped", full_width = F) %>%
  kable_styling(latex_options = "HOLD_position")
```

## Electoral College Prediction

```{r}
#| echo: false
#| warning: false
#| message: false
#| eval: true
#| label: tbl-poststrat_results2
#| tbl-cap: "2024 U.S. election electoral college estimates based on multilevel regression with post-stratification (MRP) analysis"

# electoral college
# had chatgpt make me an electoral college csv
electoral_college <- read_csv("/Users/talia/us-election-analysis/data/analysis_data/electoral_college_votes.csv", show_col_types = FALSE)

electoral_college$electoral_votes <- as.numeric(electoral_college$electoral_votes)

merged_ec <- merge(biden_support_by_state, electoral_college, by = "state")

biden_states_mean <- merged_ec |>
  filter(mean >= 0.5)

trump_states_mean <- merged_ec |>
  filter(mean < 0.5)

biden_ec_mean <- sum(biden_states_mean$electoral_votes)
trump_ec_mean <- sum(trump_states_mean$electoral_votes)

biden_states_lower <- merged_ec |>
  filter(lower >= 0.5)

trump_states_lower <- merged_ec |>
  filter(lower < 0.5)

biden_ec_lower <- sum(biden_states_lower$electoral_votes)

biden_states_upper <- merged_ec |>
  filter(upper >= 0.5)

biden_ec_upper <- sum(biden_states_upper$electoral_votes)


biden_ec_poststrat <- tibble(
  "Electoral College Estimate:" = c("Lower Estimate", "Mean Estimate", "Upper Estimate"),
  "Biden" = c(biden_ec_lower, biden_ec_mean, biden_ec_upper),
  "Trump" = c(538-biden_ec_lower, 538-biden_ec_mean, 538-biden_ec_upper)
)

# Set row names
rownames(biden_ec_poststrat) <- NULL

# electoral college table
kable(biden_ec_poststrat, align = "c") %>%
  # kable_styling(bootstrap_options = "striped", full_width = F) %>%
  kable_styling(latex_options = "HOLD_position")
```

```{r}
#| echo: false
#| warning: false
#| message: false
#| eval: true
#| label: fig-estimatedpropsupport
#| fig-cap: "Estimated proportion of each state voting for Biden in 2024 based on MRP analysis"

library(scales)  

# instrucitons and code provided in chapter 16 of telling stories with data were
# used for this visualization

biden_support_by_state |>
  ggplot(aes(y = mean, x = fct_reorder(state, mean))) +
  geom_point(color = ifelse(biden_support_by_state$mean > 0.5, "blue", "red")) +
  geom_errorbar(aes(ymin = lower, ymax = upper), width = 0, color = ifelse(biden_support_by_state$mean > 0.5, "blue", "red")) +
  geom_hline(yintercept = 0.5, linetype = "dashed") +
  labs(
    x = "State",
    y = "Estimated proportion support for Biden"
  ) +
  theme_classic() +
  scale_y_continuous(labels = scales::percent)+  # Setting y-axis to display percentages
  coord_flip() +
  theme(axis.text.y = element_text(size = 6)) 
```

```{r}
#| echo: false
#| warning: false
#| message: false
#| eval: true
#| label: fig-estimatedpropsupport2
#| fig-cap: "Estimated proportion of each state voting for Biden in 2024 Post-Stratification vs Subsetted Survey Data"

survey_analysis_data$state <- tolower(survey_analysis_data$state)
biden_support_by_state |>
  ggplot(aes(y = mean, x = fct_reorder(state, mean))) +
  geom_point(color = ifelse(biden_support_by_state$mean > 0.5, "blue", "red")) +
  geom_errorbar(aes(ymin = lower, ymax = upper), width = 0, color = ifelse(biden_support_by_state$mean > 0.5, "blue", "red")) +
  geom_point(
    data = survey_analysis_data |>
      summarise(n = n(),
                .by = c(state, vote_biden)) |>
      mutate(prop = n / sum(n),
             .by = state) |>
      filter(vote_biden == 1),
    aes(y = prop, x = state),
    color="#A9A9A9"
    ) +
  geom_hline(yintercept = 0.5, linetype = "dashed") +
  labs(
    x = "State",
    y = "Estimated proportion support for Biden"
  ) +
  theme_classic() +
  scale_y_continuous(labels = scales::percent)+ # Setting y-axis to display percentages
  coord_flip() +
  theme(axis.text.y = element_text(size = 5)) 
```

```{r}
#| echo: false
#| warning: false
#| message: false
#| eval: true
#| label: fig-electoralmappoststrat
#| fig-cap: "Electoral map based on MRP analysis"

poststrat_electoral_map <- biden_support_by_state %>%
  mutate(prop = mean) 

# this code comes from matthewwankiewicz 
# US_election_forecast/paper/forecasting_us_election.rmd

poststrat_electoral_map %>%
  mutate(statename = str_to_title(state)) %>%
  ggplot(aes(fill = prop, state = statename)) +
  geom_statebins() +
  scale_fill_gradient2(low = "#d12531", high = "#244999",
                       mid = "white", midpoint = 0.5) +
  theme_classic() +
  theme(axis.line = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank()) +
  labs(fill = "Proportion Voting \nfor Biden")
```
# Discussion {#sec-discussion}

## Popular Vote Prediction {#sec-first-point}

If my paper were 10 pages, then should be be at least 2.5 pages. The discussion is a chance to show off what you know and what you learnt from all this. The survey dataset appears to favor President Joe Biden more than the general U.S. electorate. 

## Swing States had Close Margins and Large Error Ranges
Swing states and error ranges in the MRP analysis electoral college prediction

## Weaknesses and Limitations of the Datasets

## The Limitations of Logistic Regression and the Case for (and against) SoftMax Regression {#sec-lr}

## Next Steps
Python, more recent data set, softmax regression, gradient descent
Split the survey data into training, validation, and test
Use gradient descent to find the optimal weights to maximize validation accuracy
Apply the model to the post-stratification data
Softmax regression does risk overfitting


\newpage

\appendix

# Appendix {-}

# Additional data cleaning details {#sec-data-cleaning-details}
I created a binary variable, `vote_biden` that is equal to 1 if a respondent's preferred 2024 presidential candidate is Joe Biden, or 0 if it is Donald Trump. My Cooperative Election Study Common Content survey dataset was put together in 2022, so respondents were not asked about their preferred 2024 presidential candidate. However, they were asked about their party identification (`pid3`), who they voted for in the 2016 presidential election (`presvote16post`), and who they voted for in the 2020 presidential election (`presvote20post`). I started by filtering out respondents who have no party affiliation and did not vote for either major party nominee in the 2016 and 2020 presidential elections. This was done because I am using a logistic regression model, which is only capable of performing binary classification. I used this information to create the `vote_biden` indicator variable; if a respondent's `pid3` is Democratic, or they voted for the Democratic nominee in 2016 or 2020, I label them as a Biden voter (`vote_biden = 1`). Otherwise, I label them as a Trump voter (`vote_biden = 0`). As previously stated, respondents who both voted third-party and have no party affiliation were not considered because my model is not capable of performing multi-class classification and there is no indication of whether they prefer Joe Biden or Donald Trump.

I downloaded the 2020 National Popular Vote Tracker from @cook, cleaned it to change the state column to match my survey and post-stratification data sets, and selected the `state`, `biden_won`, `dem_votes`, `rep_votes`, `other_votes`, and `dem_percent` columns. I then left-joined the 2020 National Popular Vote Tracker with both my survey and post-stratification datasets so that I could include Biden's performance in each state in the 2020 election to my model as a predictor for `vote_biden`. I added the binary variable, `biden_won`, to both my survey and post-stratification analysis datasets. `biden_won` is equal to 1 if Joe Biden won the electoral college votes of the state that the respondent lives in in the 2020 presidential election, and 0 if Donald Trump won the state in the 2020 presidential election. Maine and Nebraska have split electoral college votes; this means that the presidential nominee who wins each congressional district receives an electoral college vote, and an additional 2 electoral college votes are awarded for winning the statewide popular vote. In the 2020 presidential election, Joe Biden won the statewide popular vote in Maine, while Donald Trump won the statewide popular vote in Nebraska, although Biden won one congressional district in Nebraska, and Trump won one congressional district in Maine. `biden\_won` corresponds to the presidential nominee who won the statewide popular vote in the 2020 election, so`biden\_won = 1` for respondents who live in Maine, and `biden\_won = 0` for respondents who live in Nebraska. I use informatoin from the 2020 National Popular Vote tracker in various places throughout my analysis and discussion. 

# Additional survey data details {#sec-survey-details}
The original survey dataset contained 60,000 responses, but it was subsetted to 10,000 so that R and `rstanarm` could handle it [@citeR]. The `glm` function of the `rstanarm` package was used to fit the logistic regression model to predict 2024 presidential vote choice based on state, whether Biden or Trump won that state in 2020, sex, age bracket, race, and highest level of education completed. Although @survey advised against subsetting the 2022 CES Common Content Dataset, this was a necessary step for me. When I tried to fit the model using the original survey data set, it took hours to run and I was not able to post-stratify due to the following error: `Error: vector memory exhausted (limit reached?)`. 10,000 of the 60,000 responses were randomly selected using the `sample` function of base R. The visualizations below show the results of the exploratory data analysis conducted on the original survey data set. As seen in @fig-survey_race, @fig-survey_state2020, @fig-surveyeduc, and @fig-electoral-map-survey, the results are similar to the ones shown in @sec-survey. Therefore, I am confident that my random subset is representative of the original 2022 CES Common Content Dataset [@survey].

```{r}
#| echo: false
#| warning: false
#| message: false
#| eval: true
#| label: fig-survey_race
#| fig-cap: Preferred presidential candidates of survey respondents, by gender and race

survey_analysis_data$vote24 <- ifelse(survey_analysis_data[,1] == 1, "Joe Biden", "Donald Trump")

survey_analysis_data |>
  ggplot(aes(x = race, fill = vote24)) +
  stat_count(position = "dodge") +
  facet_wrap(facets = vars(sex)) +
  theme_minimal() +
  labs(
    x = "Race",
    y = "Number of respondents",
    fill = "Preferred Presidential Candidate"
  ) +
  coord_flip() +
  scale_fill_brewer(palette = "Set1") +
  theme(legend.position = "bottom")
# code for this graph was obtained from telling stories with data chapter 13
```

```{r}
#| echo: false
#| warning: false
#| message: false
#| eval: true
#| label: fig-survey_state2020
#| fig-cap: Preferred presidential candidate of survey respondents in states carried by Trump vs Biden in 2020
#| 
survey_analysis_data$StateWinner2020 <- ifelse(survey_analysis_data[,3] == 1, "Blue States", "Red States")
survey_analysis_data |>
  ggplot(aes(x = StateWinner2020, fill = vote24)) +
      facet_wrap(facets = vars(sex)) +
  stat_count(position = "dodge") +
  theme_minimal() +
  labs(
    y = "Number of respondents",
    fill = "State winner in 2020"
  ) +
  scale_fill_brewer(palette = "Set1") +
  theme(legend.position = "bottom")
```

```{r}
#| echo: false
#| warning: false
#| message: false
#| eval: true
#| label: fig-surveyeduc
#| fig-cap: Preferred presidential candidates of survey respondents, by highest level of education

survey_analysis_data |>
  ggplot(aes(x = educ, fill = vote24)) +
  geom_bar(position = "fill") +
  facet_wrap(facets = vars(sex)) +
  theme_minimal() +
  labs(
    x = "Highest education",
    y = "Proportion",
    fill = "Preferred Presidential Candidate"
  ) +
  coord_flip() +
  scale_fill_brewer(palette = "Set1") +
  theme(legend.position = "bottom")
```
```{r}
#| echo: false
#| warning: false
#| message: false
#| eval: true
#| label: fig-survey-urban_rural
#| fig-cap: Preferred presidential candidate of survey respondents living in urban vs rural areas

survey_analysis_data |>
  ggplot(aes(x = urban, fill = vote24)) +
  stat_count(position = "dodge") +
  facet_wrap(facets = vars(sex)) +
  theme_minimal() +
  labs(
    y = "Number of respondents",
    fill = "Preferred Presidential Candidate"
  ) +
  scale_fill_brewer(palette = "Set1") +
  theme(legend.position = "bottom")

# code for this graph is from telling stories with data chapter 13
```
```{r}
#| echo: false
#| warning: false
#| eval: true
#| message: false
#| label: fig-electoral-map-survey
#| fig-cap: Electoral college map based on the survey dataset

library(ggplot2)
library(statebins)

# this code comes from matthewwankiewicz 
# US_election_forecast/paper/forecasting_us_election.rmd
# also cited in text

survey_analysis_data <- na.omit(survey_analysis_data)
survey_electoral_map <- survey_analysis_data %>%
  group_by(state) %>%
  summarise(prop = mean(vote_biden))

survey_electoral_map %>%
  mutate(statename = str_to_title(state)) %>%
  ggplot(aes(fill = prop, state = statename)) +
  geom_statebins() +
  scale_fill_gradient2(low = "#d12531", high = "#244999",
                       mid = "white", midpoint = 0.5) +
  theme_classic() +
  theme(axis.line = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank()) +
  labs(fill = "Proportion Voting \nfor Biden")
```


# Model details {#sec-model-details}

## Posterior predictive check
```{r}
#| eval: true
#| echo: false
#| message: false
#| warning: false
#| label: fig-posterior
#| layout-ncol: 1
#| fig-cap: "Examining how the model fits, and is affected by, the data"
#| fig-subcap: ["Posterior prediction check", "Comparing the posterior with the prior"]

pp_check(us_election_model) +
  theme_classic() +
  theme(legend.position = "bottom")

posterior_vs_prior(us_election_model) +
  theme_minimal() +
  scale_color_brewer(palette = "Set1") +
  theme(legend.position = "bottom") +
  coord_flip()
```

## Markov Chain Monte Carlo
```{r}
#| echo: false
#| eval: true
#| message: false
#| warning: false
#| label: fig-mcmc
#| fig-cap: "Checking the convergence of the Markov Chain Monte Carlo (MCMC) algorithm"
#| fig-subcap: ["Rhat plot", "Trace plot"]
#| layout-ncol: 1

plot(us_election_model, "rhat") + 
  theme_classic() +
  theme(axis.text.y = element_text(size = 5))
  

cat("\n")

plot(us_election_model, "trace") 
```

## Credibility intervals
```{r}
#| echo: false
#| eval: true
#| message: false
#| warning: false
#| label: fig-modelplot
#| fig-cap: "90% Credibility intervals for the predictors of vote_biden"
modelplot(us_election_model, conf_level = 0.9) +
  labs(x = "90% credibility interval") +
  theme(axis.text.y = element_text(size = 5))
```



\newpage


# References


